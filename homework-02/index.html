<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Homework 2</title>
</head>
<body>
<p>Какие будут результаты выполнения кода и почему, напишите объяснение к каждому примеру.</p>

<p>false && true || true</p>
// из false && true получаем false т.к. оператор «&&» находит первое ложное
далее из false || true получаем true т.к. оператор «||» находит первое истинное значение
Результат: true

<p>false && (true || true)</p>
// исходя из таблицы приоритетов операторов сначала выполняется то, что в скобках
из true || true получаем true (первое) т.к. оператор «||» находит первое истинное значение
далее из false && true получаем false т.к. оператор «&&» находит первое ложное.
Результат: false

<p>+'40' + +'2'</p>
// унарный "+" совершает приведение типа к числу, обе строки будут приведены к числам,
далее происходит сложение чисел 40 и 2
Результат: 42

<p>'2' + 3 ** 2</p>
// исходя из таблицы приоритетов операторов сначала выполняется возведение в степень 3 ** 2 = 9
для бинарного "+", если хотя бы один операнд является строкой, то второй будет также преобразован в строку,
в результате чего выполняется конкатенация строк '2' + '9' = '29'
Результат: '29'

<p>3 ** 2 / 3</p>
// исходя из таблицы приоритетов операторов сначала выполняется возведение в степень 3 ** 2 = 9
происходит деление 9 / 3 = 3
Результат: 3

<p>3 ** (9 / 3)</p>
// исходя из таблицы приоритетов операторов сначала выполняется то, что в скобках 9 / 3 = 3
возведение в степень 3 ** 3 = 27
Результат: 27

<p>'10' + (5 === 6)</p>
// исходя из таблицы приоритетов операторов сначала выполняется то, что в скобках
при сравнении 5 === 6 возвращается false
для бинарного "+", если хотя бы один операнд является строкой, то второй будет также преобразован в строку
'10' + 'false' = '10false'
Результат: '10false'

<p>'10' - 5 === 6</p>
// исходя из таблицы приоритетов операторов сначала выполняется вычитание,
здесь происходит численное преобразование и строки преобразуются в числа 10 - 5 = 5
результат сравнения 5 === 6 возвращает false
Результат: false

<p>undefined + 1</p>
// специальное значения undefined не является числом и при численном преобразовании преобразуется в NaN,
при математических операциях с NaN результатом будет являться тоже NaN,
NaN + 1 = NaN
Результат: NaN

<p>(+null == false) < 1</p>
// исходя из таблицы приоритетов операторов сначала выполняется то, что в скобках,
унарный "+" производит приведение типов к числу, null в этом случае преобразуется в 0,
результат нестрогого сравнения 0 == false возвращает true,
сравнение true < 1, true преобразуется в 1 и результат сравнения 1 < 1 вернет false
Результат: false

<p>(+null == false) < 1 ** 5</p>
// исходя из таблицы приоритетов операторов сначала выполняется то, что в скобках,
унарный "+" производит приведение типов к числу, null в этом случае преобразуется в 0,
результат нестрогого сравнения 0 == false возвращает true,
возведение в степень 1 ** 5 = 1,
сравнение true < 1, true преобразуется в 1 и результат сравнения 1 < 1 вернет false
Результат: false

<p>
    var number = 5
    2 * ++number
    2 * number--
    console.log(number)
</p>
// исходя из таблицы приоритетов операторов сначала выполняется
префиксный инкремент number = 1 + 5 -> 6, выражению 2 * 6 = 12 переменная не присвоена,
поэтому результат никуда не сохранится
на третьей строке: сначала выполняется постфиксный декремент number = 6 - 1 -> 5,
выражению 2 * 6(постфикс. форма) = 12 переменная не присвоена, поэтому результат никуда не сохранится.
Поскольку возвращенный результат операторов инкремента/декремента мы не используем,
то разницы между префиксной и постфиксной формами операторов инкремента/декремента в данном примере мы не увидели.
Результат: number = 5

</body>
</html>